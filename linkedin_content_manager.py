"""
Enhanced LinkedIn Content Manager
Generates content and provides multiple posting options including manual posting support
"""

import os
import json
import shutil
import urllib.parse
from datetime import datetime
from typing import Dict, Optional, List
from loguru import logger
from config import Config

class LinkedInContentManager:
    def __init__(self):
        self.config = Config()
        self.output_dir = "ready_to_post"
        self.ensure_output_directory()
    
    def ensure_output_directory(self):
        """Create output directory for content files"""
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, "images"), exist_ok=True)
    
    def save_content_for_posting(self, content: str, image_path: Optional[str] = None, 
                                 topic: str = "General") -> Dict:
        """
        Save generated content in organized format for easy manual posting
        
        Args:
            content: The text content to post
            image_path: Optional path to image to attach
            topic: Topic category for organization
            
        Returns:
            Dictionary with file paths and posting options
        """
        try:
            # Generate timestamp for unique filenames
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Create topic-specific subdirectory
            topic_dir = os.path.join(self.output_dir, topic.replace(" ", "_").lower())
            os.makedirs(topic_dir, exist_ok=True)
            
            # Save text content with rich formatting
            text_file = os.path.join(topic_dir, f"post_{timestamp}.txt")
            with open(text_file, 'w', encoding='utf-8') as f:
                f.write(self._format_post_file(content, topic, timestamp, image_path))
            
            result = {
                'text_file': text_file,
                'timestamp': timestamp,
                'topic': topic,
                'character_count': len(content),
                'share_url': self.create_linkedin_share_url(content),
                'quick_post_url': self.create_quick_post_url(content),
                'content': content
            }
            
            # Copy and organize image if provided
            if image_path and os.path.exists(image_path):
                image_ext = os.path.splitext(image_path)[1]
                new_image_path = os.path.join(topic_dir, f"post_{timestamp}_image{image_ext}")
                shutil.copy2(image_path, new_image_path)
                result['image_file'] = new_image_path
                
                # Create optimized versions
                result['optimized_image'] = self._optimize_image_for_linkedin(new_image_path)
                
                # Update text file with image info
                with open(text_file, 'a', encoding='utf-8') as f:
                    f.write(f"\nğŸ“¸ Image file: {new_image_path}\n")
                    f.write(f"ğŸ¨ Optimized: {result.get('optimized_image', 'N/A')}\n")
            
            # Create posting instructions
            instructions_file = os.path.join(topic_dir, f"posting_guide_{timestamp}.md")
            with open(instructions_file, 'w', encoding='utf-8') as f:
                f.write(self._create_posting_guide(result))
            
            result['instructions_file'] = instructions_file
            
            logger.info(f"Content saved for posting: {text_file}")
            return result
            
        except Exception as e:
            logger.error(f"Error saving content: {e}")
            return {}
    
    def _format_post_file(self, content: str, topic: str, timestamp: str, image_path: Optional[str]) -> str:
        """Format the post content file with rich information"""
        return f"""# LinkedIn Post Content
        
## Post Details
- **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Topic:** {topic}
- **Timestamp:** {timestamp}
- **Character Count:** {len(content)} characters
- **Has Image:** {'Yes' if image_path else 'No'}

## Content (Copy this to LinkedIn)
---
{content}
---

## Quick Posting Options
1. **Copy & Paste:** Select the content above and paste into LinkedIn
2. **Quick Share:** Open the URL in posting_guide_{timestamp}.md
3. **Mobile:** Use LinkedIn mobile app for easier image posting

## Hashtag Analysis
{self._analyze_hashtags(content)}

## Engagement Tips
- Best posting times: 8-10 AM, 12-2 PM, 5-6 PM (weekdays)
- Include a question to encourage comments
- Tag relevant people or companies
- Add line breaks for readability

Generated by LinkedIn Automation Bot ğŸ¤–
"""
    
    def _analyze_hashtags(self, content: str) -> str:
        """Analyze hashtags in the content"""
        hashtags = [word for word in content.split() if word.startswith('#')]
        if hashtags:
            return f"Hashtags found: {', '.join(hashtags)} ({len(hashtags)} total)"
        return "No hashtags found - consider adding 3-5 relevant hashtags"
    
    def _create_posting_guide(self, result: Dict) -> str:
        """Create a detailed posting guide"""
        guide = f"""# LinkedIn Posting Guide

## Post Information
- **Topic:** {result.get('topic', 'N/A')}
- **Generated:** {result.get('timestamp', 'N/A')}
- **Content Length:** {result.get('character_count', 0)} characters

## Quick Post URLs
### Option 1: LinkedIn Share (Desktop)
```
{result.get('share_url', 'N/A')}
```

### Option 2: Mobile-Friendly URL
```
{result.get('quick_post_url', 'N/A')}
```

## Step-by-Step Posting Instructions

### Desktop Posting
1. Copy the content from `{os.path.basename(result.get('text_file', ''))}`
2. Go to [LinkedIn.com](https://linkedin.com)
3. Click "Start a post"
4. Paste the content
"""
        
        if result.get('image_file'):
            guide += f"""5. Click the image icon and upload: `{os.path.basename(result.get('image_file', ''))}`
6. Add alt text for accessibility
7. Review and click "Post"

### Mobile Posting (Recommended for Images)
1. Transfer image to your phone: `{os.path.basename(result.get('image_file', ''))}`
2. Open LinkedIn mobile app
3. Tap the "+" to create a post
4. Add the image first
5. Copy and paste the text content
6. Review and tap "Post"
"""
        else:
            guide += """5. Review the content
6. Click "Post"

### Mobile Posting
1. Copy the text content
2. Open LinkedIn mobile app
3. Tap the "+" to create a post
4. Paste the content
5. Review and tap "Post"
"""
        
        guide += f"""

## Content Preview
```
{result.get('content', 'N/A')[:200]}...
```

## File Locations
- Text content: `{result.get('text_file', 'N/A')}`
"""
        
        if result.get('image_file'):
            guide += f"- Image: `{result.get('image_file', 'N/A')}`\n"
        
        guide += """
## Tips for Maximum Engagement
- Post between 8-10 AM or 12-2 PM on weekdays
- Engage with comments within the first hour
- Share in relevant LinkedIn groups
- Cross-post to other social media platforms

---
*Generated by LinkedIn Automation Bot ğŸ¤–*
"""
        
        return guide
    
    def create_linkedin_share_url(self, content: str) -> str:
        """Create a LinkedIn share URL that pre-fills the post content"""
        # LinkedIn share URL format
        base_url = "https://www.linkedin.com/sharing/share-offsite/"
        
        # URL encode the content (limit to 1000 chars for URL safety)
        clean_content = content[:1000].replace('\n', ' ').strip()
        encoded_content = urllib.parse.quote(clean_content)
        
        # Create the share URL
        share_url = f"{base_url}?text={encoded_content}"
        
        return share_url
    
    def create_quick_post_url(self, content: str) -> str:
        """Create a mobile-friendly LinkedIn posting URL"""
        base_url = "https://www.linkedin.com/feed/"
        
        # For mobile, we'll create a link that opens LinkedIn feed
        # User can then create a post manually
        return base_url
    
    def _optimize_image_for_linkedin(self, image_path: str) -> str:
        """Optimize image for LinkedIn posting (placeholder for image optimization)"""
        try:
            # LinkedIn optimal image sizes:
            # Single image: 1200 x 627 pixels
            # Multiple images: 1080 x 1080 pixels
            
            # For now, just copy the image with a note about optimization
            base_name = os.path.splitext(image_path)[0]
            optimized_path = f"{base_name}_linkedin_optimized.jpg"
            
            # TODO: Add actual image resizing and optimization
            # For now, just return the original path
            return image_path
            
        except Exception as e:
            logger.error(f"Error optimizing image: {e}")
            return image_path
    
    def get_posting_summary(self) -> Dict:
        """Get a summary of all saved content ready for posting"""
        try:
            summary = {
                'total_posts': 0,
                'posts_by_topic': {},
                'recent_posts': [],
                'pending_posts': []
            }
            
            if not os.path.exists(self.output_dir):
                return summary
            
            # Scan through saved content
            for root, dirs, files in os.walk(self.output_dir):
                for file in files:
                    if file.startswith('post_') and file.endswith('.txt'):
                        summary['total_posts'] += 1
                        
                        # Extract topic from directory structure
                        topic = os.path.basename(root)
                        if topic == self.output_dir:
                            topic = 'general'
                        
                        summary['posts_by_topic'][topic] = summary['posts_by_topic'].get(topic, 0) + 1
                        
                        # Add to recent posts
                        file_path = os.path.join(root, file)
                        file_time = os.path.getmtime(file_path)
                        summary['recent_posts'].append({
                            'file': file_path,
                            'topic': topic,
                            'created': datetime.fromtimestamp(file_time).strftime('%Y-%m-%d %H:%M')
                        })
            
            # Sort recent posts by creation time
            summary['recent_posts'].sort(key=lambda x: x['created'], reverse=True)
            summary['recent_posts'] = summary['recent_posts'][:10]  # Keep last 10
            
            return summary
            
        except Exception as e:
            logger.error(f"Error generating posting summary: {e}")
            return {'error': str(e)}
    
    def create_posting_batch(self, posts: List[Dict], batch_name: str = None) -> str:
        """Create a batch of posts for scheduled posting"""
        if not batch_name:
            batch_name = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        batch_dir = os.path.join(self.output_dir, "batches", batch_name)
        os.makedirs(batch_dir, exist_ok=True)
        
        batch_info = {
            'name': batch_name,
            'created': datetime.now().isoformat(),
            'posts': [],
            'total_posts': len(posts)
        }
        
        for i, post_data in enumerate(posts, 1):
            # Save each post in the batch
            result = self.save_content_for_posting(
                content=post_data.get('content', ''),
                image_path=post_data.get('image_path'),
                topic=post_data.get('topic', f'batch_post_{i}')
            )
            
            if result:
                batch_info['posts'].append({
                    'post_number': i,
                    'text_file': result['text_file'],
                    'topic': result['topic'],
                    'character_count': result['character_count']
                })
        
        # Save batch info
        batch_file = os.path.join(batch_dir, f"{batch_name}_info.json")
        with open(batch_file, 'w', encoding='utf-8') as f:
            json.dump(batch_info, f, indent=2)
        
        # Create batch posting guide
        batch_guide = os.path.join(batch_dir, f"{batch_name}_posting_guide.md")
        with open(batch_guide, 'w', encoding='utf-8') as f:
            f.write(self._create_batch_guide(batch_info))
        
        logger.info(f"Created posting batch: {batch_name} with {len(posts)} posts")
        return batch_dir
    
    def _create_batch_guide(self, batch_info: Dict) -> str:
        """Create a guide for posting a batch of content"""
        return f"""# Batch Posting Guide: {batch_info['name']}

## Batch Information
- **Created:** {batch_info['created']}
- **Total Posts:** {batch_info['total_posts']}
- **Recommended Schedule:** Post 1-2 times per day, spacing posts 4-6 hours apart

## Posting Schedule Suggestion
"""

# Simplified posting function for compatibility
def post_to_linkedin(content: str, image_path: Optional[str] = None) -> bool:
    """
    Save content for LinkedIn posting (API posting currently limited)
    
    Args:
        content: The text content to post
        image_path: Optional path to image to attach
        
    Returns:
        True if content saved successfully
    """
    try:
        manager = LinkedInContentManager()
        result = manager.save_content_for_posting(content, image_path)
        
        if result:
            print(f"\nğŸ‰ CONTENT READY FOR LINKEDIN POSTING!")
            print(f"ğŸ“„ Text file: {result['text_file']}")
            print(f"ğŸ“Š Character count: {result['character_count']}")
            
            if 'image_file' in result:
                print(f"ğŸ“¸ Image file: {result['image_file']}")
            
            print(f"\nğŸš€ QUICK POSTING OPTIONS:")
            print(f"1. ğŸ“‹ Copy content from: {result['text_file']}")
            print(f"2. ğŸ”— Quick share URL: {result['share_url']}")
            print(f"3. ğŸ“– Full guide: {result['instructions_file']}")
            print(f"4. ğŸ’» Manual: Go to LinkedIn.com and create a post")
            
            print(f"\nğŸ’¡ TIP: Use LinkedIn mobile app for easier image posting!")
            
            return True
        else:
            logger.error("Failed to save content for posting")
            return False
            
    except Exception as e:
        logger.error(f"Error preparing content for LinkedIn: {e}")
        return False

# Example usage
if __name__ == "__main__":
    # Test the content manager
    manager = LinkedInContentManager()
    
    test_content = """ğŸš€ Just built an amazing LinkedIn automation bot using Python! 

Key features:
âœ… Fetches latest tech news from Google News
âœ… Generates AI-powered captions using BART
âœ… Creates beautiful images with Stable Diffusion
âœ… Organizes content for easy posting

The future of social media automation is here! What do you think about AI-powered content creation?

#Python #AI #LinkedInAutomation #TechNews #MachineLearning #SocialMedia #Automation"""
    
    result = manager.save_content_for_posting(test_content, topic="Tech News")
    
    if result:
        print("âœ… Test content saved successfully!")
        print(f"ğŸ“„ File: {result['text_file']}")
        print(f"ğŸ”— Share URL: {result['share_url']}")
    
    # Show summary
    summary = manager.get_posting_summary()
    print(f"\nğŸ“Š Total posts ready: {summary['total_posts']}")
    print(f"ğŸ“ Topics: {list(summary['posts_by_topic'].keys())}")